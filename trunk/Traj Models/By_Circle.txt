int AlignmentCount = 10000;
            ///////////////////////////////////////////// Рабочий цикл /////////////////////////////////////////////////
            //while (CurrentTime < 2120.0)
            while (CurrentTime < 400.0)
            {
                SINSstate.Count++;
                CurrentTime += dT;

                if (SINSstate.Count <= AlignmentCount)
                {
                    Alignment_End = CurrentTime;
                    SINSstate.FLG_Stop = 1;
                }
                else
                    SINSstate.FLG_Stop = 0;

                if (SINSstate.Count == 28751)
                    SINSstate.Count = SINSstate.Count;

                double CurTimeWithAlign = CurrentTime - Alignment_End;



                //Задание углов ориентации Курса, крена, тангажа и их производных
                //SINSstate.Heading = StartHeading + 20.0 * SimpleData.ToRadian * Math.Sin(0.04 * CurTimeWithAlign);
                //if (CurTimeWithAlign > 100.0 && CurTimeWithAlign <= 200.0) SINSstate.Heading = StartHeading + 2 * Math.Sin(Math.PI * (CurTimeWithAlign - 100.0) / 100.0);
                if (CurTimeWithAlign > 0.0 && CurTimeWithAlign <= 110.0) SINSstate.Heading = StartHeading + 4.0 * Math.PI / 2.0 * (CurTimeWithAlign - 0.0) / 110.0;
                if (CurTimeWithAlign > 150.0 && CurTimeWithAlign <= 260.0) SINSstate.Heading = StartHeading - 4.0 * Math.PI / 2.0 * (CurTimeWithAlign - 150.0) / 110.0;
                

                //if (CurTimeWithAlign > 1300.0 && CurTimeWithAlign <= 1350.0) SINSstate.Heading = StartHeading + Math.PI / 2.0 + Math.PI / 2.0 * (CurTimeWithAlign - 1300.0) / 50.0;
                //SINSstate.Roll = StartRoll + 5.0 * SimpleData.ToRadian * Math.Sin(0.021 * CurTimeWithAlign);
                //SINSstate.Pitch = StartPitch + 1.1 * SimpleData.ToRadian * Math.Sin(0.025 * CurTimeWithAlign);
                //if (CurTimeWithAlign > 200.0 && CurTimeWithAlign <= 250.0) SINSstate.Pitch = StartPitch + 0.1 * Math.Sin(Math.PI * (CurTimeWithAlign - 200.0) / 50.0);



                if (SINSstate.Heading >= Math.PI) 
                { 
                    SINSstate.Heading = SINSstate.Heading - 2.0 * Math.PI;
                    if (Math.Sign(SINSstate.Heading) != Math.Sign(SINSstate.Heading_prev) && Math.Abs(SINSstate.Heading - SINSstate.Heading_prev) > 0.1) 
                        SINSstate.Heading_prev = SINSstate.Heading_prev - 2.0 * Math.PI; 
                }
                if (SINSstate.Heading < -Math.PI) 
                { 
                    SINSstate.Heading = SINSstate.Heading + 2.0 * Math.PI;
                    if (Math.Sign(SINSstate.Heading) != Math.Sign(SINSstate.Heading_prev) && Math.Abs(SINSstate.Heading - SINSstate.Heading_prev) > 0.1) 
                        SINSstate.Heading_prev = SINSstate.Heading_prev + 2.0 * Math.PI; 
                }
                //SimpleOperations.AnglesHRP(CurrentTime - Alignment_End, SINSstate, StartHeading, StartRoll, StartPitch);
                dOrientationAngles = SimpleOperations.DerivativeOfAnglesHRP(dT, SINSstate);
                //dOrientationAngles = SimpleOperations.DerivativeOfAnglesHRP_analitic(CurrentTime - Alignment_End);

                //Задание матриц ориентации между основными трехгранниками
                SINSstate.A_sx0 = SimpleOperations.A_sx0(SINSstate);
                SINSstate.A_x0s = SINSstate.A_sx0.Transpose();
                //A_odoZ = SimpleOperations.A_odoZ(kappa1, kappa3);
                //---Формирование скоростной системы координат---//
                if (SimpleOperations.AbsoluteVectorValue(SINSstate.Vx_0) > 0.00001)
                {
                    SINSstate.CoursePitch = Math.Atan2(SINSstate.Vx_0[2], Math.Sqrt(SINSstate.Vx_0[0] * SINSstate.Vx_0[0] + SINSstate.Vx_0[1] * SINSstate.Vx_0[1]));
                    SINSstate.CourseHeading = Math.Atan2(SINSstate.Vx_0[0], SINSstate.Vx_0[1]);
                }
                else
                {
                    SINSstate.CoursePitch = 0.0;
                    SINSstate.CourseHeading = SINSstate.Heading;
                }
                SINSstate.A_cx0 = SimpleOperations.A_cx0(SINSstate);
                SINSstate.A_x0c = SINSstate.A_cx0.Transpose();
                SimpleOperations.CopyMatrix(SINSstate.A_sc, SINSstate.A_sx0 * SINSstate.A_x0c);
                SINSstate.alpha_c = -Math.Atan2(SINSstate.A_sc[2, 1], SINSstate.A_sc[1, 1]);
                SINSstate.gamma_c = -Math.Atan2(SINSstate.A_sc[0, 2], SINSstate.A_sc[0, 0]);
                SINSstate.beta_c = Math.Atan2(SINSstate.A_sc[0, 1] * Math.Cos(SINSstate.gamma_c), SINSstate.A_sc[0, 0]);





                //Задание относительной линейной скорости в различных проекциях, а так же их производных
                SINSstate.Vz[0] = 0.0;
                SINSstate.Vz[1] = 0.0;
                if (CurTimeWithAlign > 0.0 && CurTimeWithAlign <= 5.0) SINSstate.Vz[1] = 5.0 * Math.Sin(Math.PI / 2.0 * (CurTimeWithAlign - 0) / 5.0);
                if (CurTimeWithAlign > 5.0 && CurTimeWithAlign <= 105.0) SINSstate.Vz[1] = 5.0;
                if (CurTimeWithAlign > 105.0 && CurTimeWithAlign <= 110.0) SINSstate.Vz[1] = 5.0 * Math.Cos(Math.PI / 2.0 * (CurTimeWithAlign - 105.0) / 5.0);
                if (CurTimeWithAlign > 110.0 && CurTimeWithAlign <= 120.0) SINSstate.Vz[1] = 2.84 * Math.Sin(Math.PI * (CurTimeWithAlign - 110.0) / 10.0);

                if (CurTimeWithAlign > 150.0 && CurTimeWithAlign <= 155.0) SINSstate.Vz[1] = 5.0 * Math.Sin(Math.PI / 2.0 * (CurTimeWithAlign - 150.0) / 5.0);
                if (CurTimeWithAlign > 155.0 && CurTimeWithAlign <= 255.0) SINSstate.Vz[1] = 5.0;
                if (CurTimeWithAlign > 255.0 && CurTimeWithAlign <= 260.0) SINSstate.Vz[1] = 5.0 * Math.Cos(Math.PI / 2.0 * (CurTimeWithAlign - 255.0) / 5.0);
                if (CurTimeWithAlign > 260.0 && CurTimeWithAlign <= 270.0) SINSstate.Vz[1] = 2.84 * Math.Sin(Math.PI * (CurTimeWithAlign - 260.0) / 10.0);


                SINSstate.Vz[2] = 0.0;
                //if (CurTimeWithAlign > 250.0 && CurTimeWithAlign < 300.0) SINSstate.Vz[2] = 2.0 * Math.Sin(Math.PI * (CurTimeWithAlign - 250.0) / 50.0);

                /*неправильная формула*/ SINSstate.OdoAbsSpeed = Math.Sign(SINSstate.Vz[1]) * SimpleOperations.AbsoluteVectorValue(SINSstate.Vz);
                //SINSstate.OdoAbsSpeed = SINSstate.OdoAbsSpeed * Math.Cos(SINSstate.beta_c);
                SINSstate.OdoAbsSpeed = SINSstate.OdoAbsSpeed * 1.02;
                //SINSstate.OdoAbsSpeed = SINSstate.OdoAbsSpeed * Math.Cos(kappa[0]) * Math.Cos(kappa[2]);
                





                SINSstate.Vx_0 = Matrix.Multiply(SINSstate.A_x0s, SINSstate.Vz);
                //SINSstate.Vx_0[2] = 0.0;
                if (Math.Abs(SINSstate.Vz[1]) < 0.0001 && Math.Abs(SINSstate.Heading_prev - SINSstate.Heading) < 0.0000001)
                    SINSstate.FLG_Stop = 1;

                //---Формирование ПОКАЗАНИЙ ОДОМЕТРА---//
                SINSstate.OdometerData.odometer_left.Value = SINSstate.OdometerData.odometer_left.Value + SINSstate.OdoAbsSpeed * dT;
                if (SINSstate.Count % 5 == 0)
                    SINSstate.OdometerData.odometer_left.isReady = 1;
                else
                    SINSstate.OdometerData.odometer_left.isReady = 2;



                //Формирование позиционной информации
                SimpleOperations.PositionIntegration_x0(dT, SINSstate);
                //SINSstate.R_e = SimpleOperations.RadiusE(SINSstate.Latitude, SINSstate.Altitude);
                //SINSstate.R_n = SimpleOperations.RadiusN(SINSstate.Latitude, SINSstate.Altitude);


                SINSstate.GPS_Data.gps_Latitude.Value = SINSstate.Latitude;
                SINSstate.GPS_Data.gps_Latitude.isReady = 1;
                SINSstate.GPS_Data.gps_Longitude.Value = SINSstate.Longitude;
                SINSstate.GPS_Data.gps_Longitude.isReady = 1;
                SINSstate.GPS_Data.gps_Altitude.Value = SINSstate.Altitude;
                SINSstate.GPS_Data.gps_Altitude.isReady = 1;


                //Относительные угловые скорости
                RelativeAngular_sx0 = SimpleOperations.RelativeAngular_sx0(CurrentTime - Alignment_End, SINSstate, dOrientationAngles);
                RelativeAngular_x0s = SimpleOperations.RelativeAngular_x0s(CurrentTime - Alignment_End, SINSstate, dOrientationAngles);
                RelativeAngular_x0 = SimpleOperations.RelativeAngular_x0(SINSstate.Vx_0, SINSstate.Latitude, SINSstate.Altitude);
                RelativeAngular_x0_in_s = SINSstate.A_sx0 * RelativeAngular_x0;


                //Задание угловой скорости географического трехгранника
                SINSstate.u_x = SimpleOperations.U_x0(SINSstate.Latitude);
                SINSstate.u_s = SINSstate.A_sx0 * SINSstate.u_x;

                //Формирование вектора удельной силы тяжести
                SINSstate.g = SimpleOperations.GilmertGravityForce(SINSstate.Latitude, SINSstate.Altitude);
                SINSstate.F_x = SimpleOperations.Force_x0(dT, SINSstate.Vx_0, SINSstate.Vx_0_prev, RelativeAngular_x0, SINSstate.u_x, SINSstate.g);
                SINSstate.F_z = SINSstate.A_sx0 * SINSstate.F_x;


                //Формирование Абсолютной угловой скорости приборного трехгранника
                for (int i = 0; i < 3; i++)
                    SINSstate.W_z[i] = RelativeAngular_sx0[i] + RelativeAngular_x0_in_s[i] + SINSstate.u_s[i];

                //-----------------------------------------Информации о местоположении одометра---------------------------------------------
                //OdometerCoordinate_x0 = Matrix.Multiply(A_x0s, OdometerCoordinate_s);
                //OdometerPosition[0] = Position[0] + OdometerCoordinate_x0[1] / SimpleOperations.RadiusN(Position[0], Position[2]);
                //OdometerPosition[1] = Position[1] + OdometerCoordinate_x0[0] / SimpleOperations.RadiusE(Position[0], Position[2]) / Math.Cos(Position[0]);
                //OdometerPosition[2] = Position[2] + OdometerCoordinate_x0[2];

                //temp = Matrix.Multiply(Matrix.SkewSymmetricMatrix(RelativeAngular_x0s), OdometerCoordinate_x0);
                //for (int i = 0; i < 3; i++)
                //    OdometerVelocity_x0[i] = Velocity_x0[i] + temp[i];

                ////Добавление несоосности оси одометра и оси Oz1
                //temp = Matrix.Multiply(A_odoZ, Matrix.Multiply(A_sx0, OdometerVelocity_x0));

                ////---Формирование самого измерения пройденного пути---//
                //OdometerMeasure = SimpleOperations.AbsoluteVectorValue(temp);///////////!!!///////////


                //---Поворот приборных осей относительно динамической---//
                double[] kappa = new double[3]; kappa[0] = 0.0 * SimpleData.ToRadian; kappa[2] = 1.0 * SimpleData.ToRadian;
                SimpleOperations.CopyArray(SINSstate.F_z, SimpleOperations.A_odoZ(kappa[0], kappa[2]) * SINSstate.F_z);
                SimpleOperations.CopyArray(SINSstate.W_z, SimpleOperations.A_odoZ(kappa[0], kappa[2]) * SINSstate.W_z);


                double df_0 = 0.0001;
                double dW_0 = 0.05 * SimpleData.ToRadian / 3600.0; //0.2 grad/hour

                SINSstate.F_z[0] += (rnd_1.NextDouble() - 0.5) / 100.0;
                SINSstate.F_z[1] += (rnd_2.NextDouble() - 0.5) / 100.0;
                SINSstate.F_z[2] += (rnd_3.NextDouble() - 0.5) / 100.0;
                SINSstate.W_z[0] -= (rnd_4.NextDouble() - 0.5) / 10000.0;
                SINSstate.W_z[1] -= (rnd_5.NextDouble() - 0.5) / 10000.0;
                SINSstate.W_z[2] -= (rnd_6.NextDouble() - 0.5) / 10000.0;

                SINSstate.F_z[0] += df_0;
                SINSstate.F_z[1] += df_0;
                SINSstate.F_z[2] += df_0;
                SINSstate.W_z[0] -= dW_0;
                SINSstate.W_z[1] -= dW_0;
                SINSstate.W_z[2] -= dW_0;

                //Вывод сформированных данных в файл
                if (SINSstate.Count % 5 == 0)
                    ExitInfoClear.WriteLine(CurrentTime.ToString() + " " + SINSstate.F_z[0].ToString() + " " + SINSstate.F_z[1].ToString() + " " + SINSstate.F_z[2].ToString() + " " +
                                SINSstate.W_z[0].ToString() + " " + SINSstate.W_z[1].ToString() + " " + SINSstate.W_z[2].ToString() + " " + SINSstate.Vz[0].ToString() + " " + SINSstate.Vz[1].ToString() + " " + SINSstate.Vz[2].ToString() + " " + 
                                SINSstate.Vx_0[0].ToString() + " " + SINSstate.Vx_0[1].ToString() + " " + SINSstate.Vx_0[2].ToString() + " " +
                                SINSstate.CourseHeading + " " + SINSstate.CoursePitch + " " + SINSstate.beta_c + " " + SINSstate.alpha_c + " " + SINSstate.gamma_c + " " +
                                SINSstate.Heading.ToString() + " " + SINSstate.Roll.ToString() + " " + SINSstate.Pitch.ToString() + " " +
                                SINSstate.Latitude.ToString() + " " + SINSstate.Longitude.ToString() + " " + SINSstate.Altitude.ToString() + " " +
                                OdometerPosition[0].ToString() + " " + OdometerPosition[1].ToString() + " " + OdometerPosition[2].ToString() + " " +
                                SimpleOperations.AbsoluteVectorValue(SINSstate.F_z).ToString() + " " + SINSstate.g.ToString());


                Imitator_Data_for_Process.WriteLine(SINSstate.Count + " " + SINSstate.F_z[1] + " " + SINSstate.F_z[2] + " " + SINSstate.F_z[0] + " " + SINSstate.W_z[1] + " " + SINSstate.W_z[2] + " " + SINSstate.W_z[0]
                                 + " " + SINSstate.GPS_Data.gps_Latitude.Value.ToString() + " " + SINSstate.GPS_Data.gps_Latitude.isReady.ToString() + " " + SINSstate.GPS_Data.gps_Longitude.Value.ToString()
                                 + " " + SINSstate.GPS_Data.gps_Longitude.isReady.ToString() + " " + SINSstate.GPS_Data.gps_Altitude.Value.ToString() + " " + SINSstate.GPS_Data.gps_Altitude.isReady.ToString()
                                 + " " + SINSstate.GPS_Data.gps_Vn.Value.ToString() + " " + SINSstate.GPS_Data.gps_Vn.isReady.ToString() + " " + SINSstate.GPS_Data.gps_Ve.Value.ToString() + " " + SINSstate.GPS_Data.gps_Ve.isReady.ToString()
                                 + " " + SINSstate.FLG_Stop.ToString() + " " + SINSstate.OdometerData.odometer_left.Value.ToString() + " " + SINSstate.OdometerData.odometer_left.isReady.ToString()
                                 + " " + SINSstate.OdometerData.odometer_right.Value.ToString() + " " + SINSstate.OdometerData.odometer_right.isReady.ToString());


                SimpleOperations.CopyArray(SINSstate.Vz_prev, SINSstate.Vz);
                SimpleOperations.CopyArray(SINSstate.Vx_0_prev, SINSstate.Vx_0);
                SINSstate.Heading_prev = SINSstate.Heading;
                SINSstate.Roll_prev = SINSstate.Roll;
                SINSstate.Pitch_prev = SINSstate.Pitch;
                SINSstate.Latitude_prev = SINSstate.Latitude;
                SINSstate.Longitude_prev = SINSstate.Longitude;
                SINSstate.Altitude_prev = SINSstate.Altitude;
            }