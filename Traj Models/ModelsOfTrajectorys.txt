				
//-----------------------------------------------------------------------------------------------------------------------------------------------------
				//Задание углов ориентации Курса, крена, тангажа и их производных
                //SINSstate.Heading = StartHeading + 20.0 * SimpleData.ToRadian * Math.Sin(0.04 * CurTimeWithAlign);
                if (CurTimeWithAlign > 100.0 && CurTimeWithAlign <= 200.0) SINSstate.Heading = StartHeading + 2 * Math.PI * (CurTimeWithAlign - 100.0) / 100.0;
                if (CurTimeWithAlign > 300.0 && CurTimeWithAlign <= 350.0) SINSstate.Heading = StartHeading + 3.0 * Math.PI / 2.0 * (CurTimeWithAlign - 300.0) / 50.0;
                if (CurTimeWithAlign > 500.0 && CurTimeWithAlign <= 550.0) SINSstate.Heading = StartHeading - Math.PI / 2.0 + 3.0 * Math.PI / 2.0 * (CurTimeWithAlign - 500.0) / 50.0;
                if (CurTimeWithAlign > 650.0 && CurTimeWithAlign <= 700.0) SINSstate.Heading = StartHeading - 2.0 * Math.PI / 2.0 + 3.0 * Math.PI / 2.0 * (CurTimeWithAlign - 650.0) / 50.0;
                if (CurTimeWithAlign > 900.0 && CurTimeWithAlign <= 950.0) SINSstate.Heading = StartHeading + 1.0 * Math.PI / 2.0 + 3.0 * Math.PI / 2.0 * (CurTimeWithAlign - 900.0) / 50.0;
                //SINSstate.Roll = StartRoll + 5.0 * SimpleData.ToRadian * Math.Sin(0.021 * CurTimeWithAlign);
                //SINSstate.Pitch = StartPitch + 1.1 * SimpleData.ToRadian * Math.Sin(0.025 * CurTimeWithAlign);
                //if (CurTimeWithAlign > 200.0 && CurTimeWithAlign <= 250.0) SINSstate.Pitch = StartPitch + 0.1 * Math.Sin(Math.PI * (CurTimeWithAlign - 200.0) / 50.0);
                //if (CurTimeWithAlign > 400.0 && CurTimeWithAlign <= 500.0) SINSstate.Pitch = StartPitch + 0.05 * Math.Sin(Math.PI * (CurTimeWithAlign - 400.0) / 100.0);

				//Задание относительной линейной скорости в различных проекциях, а так же их производных
                SINSstate.Vz[0] = 0.0;
                if (CurTimeWithAlign > 100.0 && CurTimeWithAlign <= 200.0) SINSstate.Vz[0] = 3.0 * Math.Sin(Math.PI * (CurTimeWithAlign - 100.0) / 100.0);
                if (CurTimeWithAlign > 300.0 && CurTimeWithAlign <= 350.0) SINSstate.Vz[0] = 3.0 * Math.Sin(Math.PI * (CurTimeWithAlign - 300.0) / 50.0);
                if (CurTimeWithAlign > 500.0 && CurTimeWithAlign <= 550.0) SINSstate.Vz[0] = 4.0 * Math.Sin(Math.PI * (CurTimeWithAlign - 500.0) / 50.0);
                if (CurTimeWithAlign > 650.0 && CurTimeWithAlign <= 700.0) SINSstate.Vz[0] = 4.0 * Math.Sin(Math.PI * (CurTimeWithAlign - 650.0) / 50.0);
                if (CurTimeWithAlign > 900.0 && CurTimeWithAlign <= 950.0) SINSstate.Vz[0] = 4.0 * Math.Sin(Math.PI * (CurTimeWithAlign - 900.0) / 50.0);
                SINSstate.Vz[1] = 0.05 * (CurrentTime - Alignment_End);
                if (CurrentTime > 700.0)
                    SINSstate.Vz[1] = Math.Max(0.05 * (1300.0 - CurrentTime), 0.0);
                SINSstate.Vz[2] = 0.0;
                //if (CurTimeWithAlign > 250.0 && CurTimeWithAlign < 300.0) SINSstate.Vz[2] = 2.0 * Math.Sin(Math.PI * (CurTimeWithAlign - 250.0) / 50.0);


                SINSstate.Vx_0 = Matrix.Multiply(SINSstate.A_x0s, SINSstate.Vz);
                SINSstate.Vx_0[2] = 0.0;

                if (Math.Abs(SINSstate.Vz[1]) < 0.0001)
                    SINSstate.FLG_Stop = 1;

                SINSstate.OdoAbsSpeed = Math.Sign(SINSstate.Vz[1]) * SimpleOperations.AbsoluteVectorValue(SINSstate.Vz);
                SINSstate.OdoAbsSpeed = SINSstate.OdoAbsSpeed * Math.Cos(SINSstate.beta_c);
//-----------------------------------------------------------------------------------------------------------------------------------------------------

